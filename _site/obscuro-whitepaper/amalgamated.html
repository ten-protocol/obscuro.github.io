<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>TEN</title>
<meta name="description" content="TEN is an Ethereum-equivalent confidential smart contract L2 network.">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_UK">
<meta property="og:site_name" content="TEN">
<meta property="og:title" content="TEN">
<meta property="og:url" content="http://localhost:4000/obscuro-whitepaper/amalgamated.html">


  <meta property="og:description" content="TEN is an Ethereum-equivalent confidential smart contract L2 network.">












<link rel="canonical" href="http://localhost:4000/obscuro-whitepaper/amalgamated.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "TEN",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->




<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- Custom Scripts and Styles -->
<script src="/assets/js/custom.js" defer></script>

<!-- Custom Favicon -->
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-32x32.png">
<link rel="shortcut icon" href="/assets/images/favicon-32x32.png">

<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/favicon-32x32.png" alt="TEN"></a>
        
        <a class="site-title" href="/">
          TEN
          <span class="site-subtitle">The Final Network - a TEE-native encrypted Ethereum Layer 2 for the new internet.</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/assets/images/ten-whitepaper-1-0-0.pdf">Download PDF</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <h1 id="ten">TEN</h1>
<p><strong>Confidential Smart Contracts for Ethereum</strong></p>

<blockquote>
  <p>/TENː/</p>
  <ol>
    <li>天 (Japanese) Heaven; sky; the celestial;</li>
    <li><strong>T</strong>he <strong>E</strong>ncrypted <strong>N</strong>etwork.</li>
  </ol>
</blockquote>

<p>V1.0.0, November 2025</p>

<p><em>Note: Some diagrams will refer to the former name Obscuro</em></p>

<p>James Carlyle, Tudor Malene, Cais Manai, Neal Shah, Gavin Thomas, Roger Willis; with significant additional <a href="./appendix#contributors">contributors</a>.</p>

<h1 id="abstract">Abstract</h1>
<p>We present TEN, a decentralised Ethereum Layer 2 Rollup protocol designed to achieve data confidentiality, computational privacy and prevent <a href="https://ethereum.org/en/developers/docs/mev/">Maximal Extractable Value (MEV)</a> by leveraging hardware-based <a href="https://en.wikipedia.org/wiki/Trusted_execution_environment">Trusted Execution Environments (TEE)</a>.</p>

<p>The design of TEN ensures that hardware manufacturers do not have to be trusted for the safety of the ledger. If one manufacturer turns malicious or there is a breach in the TEE technology, the protocol falls back to the behaviour of a public blockchain that preserves the ledger’s integrity but makes the transactions public.</p>

<p>The design also focuses on preserving privacy for the limited period when it matters most, which removes the need for a privacy technique that is robust against all adversaries in perpetuity.</p>

<p>TEN sits in what we believe is a sweet spot between the existing <a href="https://ethereum.org/en/developers/docs/scaling/layer-2-rollups/">rollup-based L2 offerings</a> Optimistic and ZK Rollups. The use of <a href="https://www.intel.co.uk/content/www/uk/en/security/confidential-computing.html">confidential computing techniques</a> coupled with economic incentives allows TEN to retain the performance and programming model simplicity of Optimistic rollups, and on top of that attain confidentiality, short withdrawal periods, and address MEV.</p>

<h1 id="motivation">Motivation</h1>
<p>Public blockchain networks have experienced a period of strong growth in 2020-2021, with new use-cases for smart contracts encompassing the finance and art worlds. Decentralised Finance (DeFi) has seen enormous inflows of capital, with the top applications seeing the equivalent of $10 billion (summer 2021) of liquidity added, and this has helped push the overall capitalisation of cryptoassets above $2 trillion (summer 2021). Meanwhile, <em>Non-Fungible Tokens</em> (NFTs) surged in value to $10 billion (autumn 2021).</p>

<p>Public blockchains rely on the entire network seeing all transactions in order to be able to validate them and secure the network. This makes them <em>transparency engines</em>. Unfortunately, this creates a front-running issue, known as <em>Maximal Extractable Value</em> (MEV), where miners or stakers and block proposers may steal value by observing user transactions and then preempting them. For example, a miner or bot may observe a user’s desire to buy an asset at market price with an automated market maker, insert their purchase ahead in the processing queue by paying a higher transaction fee, causing the price to go up for the user, and then sell their purchase at a higher price and extract a profit from the user.</p>

<p>By some estimates, front-running was valued at $1.4 billion annually in early 2021. This means users of public blockchain networks are not deriving the full economic benefits of the technology. In addition, the transparent nature of the technology makes them inappropriate for many commercial and personal use-cases, where the confidential nature of interactions and deals should be maintained.</p>

<p>TEN is a decentralised Ethereum Layer 2 Rollup protocol designed to address the above problems, introduce new use-cases, and unlock blockchain technology’s full potential and economic advantages.</p>

<h2 id="differentiators">Differentiators</h2>
<ul>
  <li>TEN leverages Ethereum, a public blockchain with the greatest adoption,  legitimacy, security, and liquidity, as a base layer to handle security and data availability and manage the inflow and outflow of value.</li>
  <li>TEN keeps all transactions and the internal state of application contracts encrypted and hidden, and so provides a credible solution to MEV.</li>
  <li>By providing an <em>Ethereum Virtual Machine</em> (EVM) compatible VM, deploying existing contracts to TEN with minimal change may be possible.</li>
  <li>TEN is trustless and decentralised. It takes processing from the Ethereum Layer-1 (L1) and allows lower transaction costs similar to other Layer-2 (L2) networks.</li>
  <li>TEN leverages TEEs for privacy but not for integrity and is not affected by the limitations of hardware-based confidential computing.</li>
  <li>TEN guarantees quick finality by synchronising the publishing of rollups to the cadence of the L1 blocks.</li>
  <li>TEN introduces a novel mechanism to allow application developers to balance the need for user data privacy (and MEV prevention) with the need to deter long-term illegal behaviour.</li>
</ul>

<h1 id="challenges">Challenges</h1>

<p>As well as preserving the confidentiality of user data, the other main goals of this protocol are to be fully permissionless, decentralised and a generic smart-contract execution engine compatible to the greatest extent with the EVM.</p>

<p>In this section, we enumerate the key challenges we faced when designing the TEN protocol.</p>

<ul>
  <li>
    <p>Relying on hardware-based TEEs for applications where significant value depends on the security of the hardware poses several challenges. A system designed to manage value should not allow an attacker capable of compromising secure hardware to take ownership of the value under any circumstances. In other words, the ledger’s integrity should not depend on TEEs being 100% hack-proof or the hardware manufacturer being 100% trustworthy. TEN uses the security of Ethereum combined with game theory to detect and correct eventual TEE hacks.</p>
  </li>
  <li>
    <p>A system where everything is encrypted all the time is not usable. There must be a way for users to query their data or prove it to third parties. Additionally, an existing application contract that reveals internal state (such as the balanceOf(address) function of the ERC-20 standard used to look up anyone’s holding) need to be considered carefully; since while TEN would prevent the state of the contract from being visible, the functions might not.</p>
  </li>
  <li>
    <p>Another critical challenge for this protocol is the prevention of MEV. Because user transactions and execution are not visible to TEN nodes, one might naively assume that this problem is solved. Unfortunately, that is not strictly true since aggregators might gain useful information through side-channels and use that to extract value. For example, an aggregator might own some accounts and submit transactions to them in critical moments and then query for results. TEN addresses this by introducing delays in key moments to prevent aggregators from performing replay-attacks which can generally be used for side-channels.</p>
  </li>
  <li>
    <p>A privacy-preserving platform should consider illegal usage and design mechanisms to help application developers avoid and prevent it. An important insight in this direction is that the value of confidentiality decays over time, to the point where transactions may just be of historical interest. For many transactions involving value, it is critical that they are not public when processed and cannot be front-run, but for others, they are price-sensitive for a longer period. TEN uses this insight and implements a flexible policy for delayed transaction revelation. The knowledge that transactions become public in the future is a deterrent for users to engage in criminal behaviour because law-enforcement agencies will eventually catch up. <a href="./appendix#alternative-revelation-options">Alternative</a> options have been considered.</p>
  </li>
  <li>
    <p>One crucial challenge of such a system is ensuring that some catastrophic event cannot leave all the value locked. The mechanism that prevents this is covered in the <a href="./threat-model">Threat-Model analysis</a>.</p>
  </li>
  <li>
    <p>High transaction fees are one of the main barriers to entry for Ethereum. TEN addresses this by introducing a novel approach to calculate fees based on the actual costs of the running nodes.</p>
  </li>
</ul>

<h1 id="technical-background">Technical Background</h1>

<p>This section briefly covers the key technologies on which TEN relies.</p>

<p>We recommend reading through the “Trusted Execution Environment” section because it introduces concepts and notations used throughout the paper.</p>

<h2 id="ethereum">Ethereum</h2>
<p>Ethereum is a public, transparent, permissionless blockchain system and network of nodes, supporting account-based smart contracts, where business logic can be deployed as code to create an immutable and uncensorable contract which can hold and control the flow of value. The Ethereum mainnet went live in 2015 and is the most mature and adopted smart contract system. Read more on the official <a href="https://ethereum.org/en/">website</a>.</p>

<h2 id="trusted-execution-environment">Trusted Execution Environment</h2>
<p>A TEE is a secure area of a central processor or CPU. It guarantees code and data loaded inside to be protected with respect to confidentiality and integrity as it is processed. TEN focuses initially on Intel’s SGX, based on the team’s 5 years of experience developing a confidential computing product with it. The TEE data cannot be read or processed outside the enclave, including processes running at higher privilege levels in the same host.</p>

<p>An SGX-capable CPU has two device root keys that are fused into it by the manufacturer, the <em>Root Provisioning Key</em> (RPK) and the <em>Root Sealing Key</em> (RSK). The RPK is known to Intel and used to prove a CPU is genuine via remote attestation and the RSK is not known to any entity outside the CPU. These keys can be used to create other CPU specific keys. In this whitepaper, we will refer to them as the <em>Enclave Key</em> (EK).  Processes and users outside the enclave encrypt data that is only meant for the enclave using keys generated inside the enclave. When the enclave wishes to store data, it is again encrypted so that the host (the server which stores the data) is not able to see it.</p>

<p>Attestation allows user verification that the enclave is running on a genuine SGX capable CPU that is properly-patched, and the application running inside the enclave matches a particular codebase and is un-tampered before the user shares confidential data with it. This allows the user or someone trusted by them to audit the code of the application in advance and know for sure that only that code will see that data.</p>

<p>In TEN’s case, the SGX application is a virtual machine largely compatible with the EVM, allowing execution of existing Ethereum smart contracts, along with the rollup functionality necessary to interact with the L1 contract.</p>

<p>The <em>Trusted Computing Base</em> (TCB) is defined as the set of computing technologies that must be working correctly and not be malicious or compromised for a security system to operate. The TCB is composed of the hardware TCB (the CPU) and the software TCB (the CPU microcode and the application).
Attestation provides to the Verifier a report containing the details about all the components of a TCB, like CPU type, the SGX security version number (CPUSVN) and the version of the application.</p>

<p>An attestation report that was deemed as secure could become insecure if a vulnerability is disclosed. At that moment, the system needs to be re-secured, a process which is called TCB recovery.</p>

<p>This whitepaper refers to the <em>Attestation Report</em> (AR) as a generic object that describes the TCB and also contains an encryption key referred to as the <em>Attestation Key</em> (AK), and as <em>Attestation Constraints</em> (AC) to a set of constraints that a report must satisfy to be considered secure at a point in time. The constraints will change over time as vulnerabilities are discovered, the software is upgraded with new features or to keep up with the evolution of the EVM. The TEN nodes will have to upgrade to continue participating in the network.</p>

<p>Any message originating from an enclave can be signed with the AK. This is a guarantee for the recipient that it must have originated only inside a valid enclave.</p>

<p>The diagram below is a conceptual high-level overview of the mechanism by which a TEE manufacturer and a group of security auditors propagate trust to the output of the computing performed inside the TEE.</p>

<p><img src="./images/tee-architecture.png" alt="tee architecture" /></p>

<p>A signature from the EK attests that a signed data packet originates from a genuine CPU. That is not enough for the output of typical confidential computing use cases, as clients have to know what program runs inside the CPU and what firmware.</p>

<p>To solve this problem, the TEE generates a new key (the AK) derived from the RSK, which is then included in the attestation report, together with the software and hardware versions, and signs this report with the EK.</p>

<p>By this mechanism, data packets signed with the AK include the trust from the genuine CPU and the hash of the program attested by the group of auditors.</p>

<h2 id="rollups">Rollups</h2>
<p>The two approaches to scaling L1 blockchains are to improve the capacity of the blockchain, or move processing away from it but tie back to it.</p>

<p>The first approach can make the blockchain more centralised, as the cost of node infrastructure increases (limiting the number of participants able to afford it) or the number of nodes involved in consensus decreases. A variation splits the accounts into shards, allowing validation to happen in parallel, and this is the current approach on the Eth2 roadmap.</p>

<p>The second approach is to allow users to engage with contracts on a second-layer network of nodes, where the majority of the processing work is undertaken. One example of the second approach is <em>rollups</em>, where the L2 transactions are verified and posted in compressed form in a single rollup transaction to the L1 blockchain. There is an L1 contract which processes deposits and withdrawals. In zero-knowledge rollups, L1 nodes can undertake a lightweight process of verification of the correctness of activity on the L2 network, whereas in optimistic rollups, the L2 transactions submitted are assumed to be correct, but another L2 node may disprove them during a challenge window.</p>

<h1 id="high-level-design">High Level Design</h1>
<p>TEN is designed as an L2 protocol, where user activity is moved <em>off-chain</em> from the L1, and it follows the increasingly common rollup pattern to store transaction data on the L1 chain to achieve censorship-resistant data availability. This is <a href="https://notes.ethereum.org/@vbuterin/data_sharding_roadmap">leading to proposals</a> to reduce calldata storage costs on Ethereum. Most <a href="https://vitalik.ca/general/2021/01/05/rollup.html">rollup</a> implementations exist to provide scalability for L1 networks, but the prime objective of TEN is to provide confidentiality. The rollups contain the entire encrypted transaction data.</p>

<p>L2 networks have a unidirectional dependency on an L1 network: while the L2 network relies on the L1 network to provide an immutable and public record of transaction data and to provide censorship resistance, liveness and availability, the L1 network is unaware of any individual L2 network. L2 submitted rollups are just normal L1 transactions.</p>

<p>The following diagram shows the interactions between the two decentralised networks, Ethereum (L1) and TEN (L2): TEN is formed of Nodes called Aggregators, who compete to process user transactions, roll them up, and submit for inclusion in Ethereum blocks. Ethereum, through its protocol, leverages its own nodes to produce Ethereum blocks containing, amongst other things, the submitted TEN rollups.</p>

<p><img src="./images/l1-l2-interaction.png" alt="L1-L2 Interaction" /></p>

<p>On the bottom right, this diagram also depicts the state of a simple rollup chain as it is found in the sequential L1 blocks.</p>

<h2 id="l1-network">L1 Network</h2>
<p>On the L1 network there are several regular Ethereum contracts, referred to as Management Contracts.</p>

<p>Note: the L1 design is covered in more detail in <a href="./l1-contracts">L1 Contracts</a>.</p>

<h3 id="network-management">Network Management</h3>
<p>This contract is the gatekeeper for the protocol. Any TEN node wishing to join the network will have to interact with this contract and prove it is valid. 
This contract will also manage the TEE attestation requirements and will be able to verify attestation reports.</p>

<p>It will also manage the stake of the participants able to submit rollups known as Aggregators.</p>

<p><em>Note: The stake is a piece of the game-theory puzzle that ensures that TEN participants have the right incentives to follow the protocol.</em></p>

<h3 id="rollup-management">Rollup Management</h3>
<p>This module accepts rollups submitted by L2 nodes and includes them in the rollup-chain structure. It works together with the bridge in processing withdrawal requests from users.</p>

<h3 id="ten-bridge">TEN Bridge</h3>
<p>This contract is very important for the solution’s security since it will protect all liquidity deposited by Ethereum end-users, and reflected in the confidential TEN ledger.</p>

<h2 id="l2-network">L2 Network</h2>
<p>The goal of the L2 design is to create a fair, permissionless, and decentralised network of nodes with valid TEEs who cannot see the transactions they are processing while collaborating to manage a ledger stored as rollups in the L1. The ledger should preserve its integrity even in the face of catastrophic TEE hacks.</p>

<p>All TEN nodes have to go through the attestation process with the Network Management contract before receiving the shared secret and participating.</p>

<p>Note: the shared secret is covered in the <a href="./cryptography">cryptography section</a>.</p>

<h3 id="l2-nodes">L2 Nodes</h3>
<p>There are two categories of nodes in the TEN network:</p>

<h4 id="aggregator-nodes">Aggregator Nodes</h4>
<p>Aggregators are the TEN nodes whose TEEs are in possession of the <em>shared secret</em> and can submit rollups to the L1. To gain this privilege, these nodes must pledge a stake.</p>

<p>End users send encrypted transactions to any registered Aggregators who then gossip the transactions. Every round, one of the Aggregators publishes the transaction in a rollup.</p>

<p>Aggregators have the following functions:</p>
<ul>
  <li>Integrate with an L1 node to monitor published blocks and to submit rollups.</li>
  <li>Gossip with the other aggregators registered in the Management Contract.</li>
  <li>Interact with the TEE module of the node:
    <ul>
      <li>Submit user encrypted transactions.</li>
      <li>Submit signed user balance requests and encrypted responses back to the users.</li>
      <li>Submit proofs of block inclusion and receive signed rollups.</li>
    </ul>
  </li>
  <li>Store data encrypted by the TEE and make it available when the TEE requests it. Act as an encrypted database.</li>
</ul>

<p>Note that logically a node is split into two main sections:</p>
<ul>
  <li>The section that is controlled by the node operator</li>
  <li>The TEE, which is attested to the Management contract and is in effect controlled by the governance body of TEN.</li>
</ul>

<p>These are the steps to become an Aggregator.</p>
<ul>
  <li>Register with the L1 Network Management contract and pay a significant stake in the TEN token. The stake has multiple roles. The first one is to penalise Aggregators who attempt to hack the protocol, and second is for the Aggregators to buy into the ecosystem, so that they will make an effort to keep it running smoothly.</li>
  <li>Set up a server with a valid, unaltered and up-to-date TEE and provide an attestation to the Management Contract.</li>
  <li>On seeing this request to join the network published to the L1, another registered TEE will share the shared secret.</li>
  <li>Once in possession of the secret, the TEE can start processing all the L2 transactions that are stored on the L1 blockchain and build the state.</li>
  <li>Once this is completed, the new Aggregator can join the gossip with the other Aggregators and participate in the lottery for producing rollups.</li>
  <li>Some end users will send encrypted instructions directly to this server, and it will gossip these with other nodes in the L2 network.</li>
  <li>As Aggregators process messages, they maintain the L2 state in the encrypted TEE memory and then journal encrypted data in a local database. If they are the winner of the round they can create a valid rollup and publish it to L1.</li>
  <li>All Aggregators keep track of the blocks submitted to the Management Contract to make sure they are up-to-date with the source of truth.</li>
  <li>The first Aggregator to register has a special role, as it has to create the <em>Shared secret</em>.</li>
</ul>

<p>Note: Each Aggregator needs an ETH balance on the L1 to pay for the submission of the rollup.</p>

<p>The steps to register as an Aggregator are shown in the following diagram:
<img src="./images/aggregator-stake.png" alt="aggregator staking" /></p>

<h4 id="verifier-nodes">Verifier Nodes</h4>
<p>Verifiers are TEE-equiped TEN nodes in possession of the shared secret and play a strong role in consensus security. They are configured differently and have not pledged the stake nor are they part of the Aggregator gossip network. To receive the L2 transactions, they monitor the L1 network and calculate the state based on the rollups submitted there.</p>

<p>End users can interact with either Aggregators or Verifiers to receive events on submitted transactions or query their accounts’ balance. Anyone can become a Verifier with minimal cost if they have compatible hardware.</p>

<p>Allowing these two categories lowers the bar for participation, thus making the network more robust and decentralised since more independent parties guard the shared secret and can react in the face of an attack.</p>

<h2 id="rollup-data-structure">Rollup Data Structure</h2>
<p>The Management Contract implements a blockchain-like data structure to store the rollups. Each rollup points to a parent rollup, and at any time there can be multiple competing sibling rollups. Similar to L1 blockchains, it is the responsibility of the individual L2 nodes to decide which sibling is valid. The difference is that un-hacked nodes are running the same code and thus are not able to build upon an invalid rollup, or even to build on different rollups.</p>

<p>The diagram below depicts an L1 blockchain (in black). Each block contains a snapshot of the state of the TEN rollup chain (in Red). In this example, there are 5 TEN nodes.</p>

<p><img src="./images/block-rollup-simple.png" alt="block rollup simple" /></p>

<p>Note that forks are possible on both layers, and it is the responsibility of the TEN nodes to navigate and choose the most likely L1 block. The following diagram depicts a couple of complex scenarios, where firstly an extra Aggregator publishes an additional rollup to a block, and secondly the L1 chain forks.</p>

<p><img src="./images/block-rollup-complex.png" alt="block rollup complex" /></p>

<p>Note that this diagram will be dissected more after we introduce the consensus protocol. At this moment, it intends to give a high-level mental model of the decentralised nature of the L2 data model on top of the decentralised nature of the L1.</p>

<h1 id="consensus---proof-of-block-inclusion">Consensus - Proof of Block Inclusion</h1>
<p>TEN uses a novel decentralised round-based consensus protocol based on a fair lottery and synchronisation with the L1, designed explicitly for L2 rollups, called <em>Proof Of Block Inclusion</em> (POBI). It solves, among others, the fair leader election problem, which is a fundamental issue that all decentralised rollup solutions have to address. POBI is inspired by <a href="https://www.investopedia.com/terms/p/proof-elapsed-time-cryptocurrency.asp">Proof Of Elapsed Time</a>.</p>

<h2 id="high-level-description">High-Level Description</h2>
<p>The high level goals of the POBI protocol are:</p>

<ol>
  <li>Each round, distribute the sequencer function fairly among all the active registered Aggregators.</li>
  <li>To synchronise the L2 round duration to L1 rounds. Because the L1 is the source of truth, the finality of the L2 transactions is dependent on the finality of the L1 rollup transaction that includes them, which means there is no advantage in publishing multiple rollups in a single L1 block. It is impossible to decrease the finality time below that of the L1, and, on the other hand, publishing L2 rollups less frequently means that L2 finality is unnecessarily long. The optimum frequency is to publish one rollup per L1 block.</li>
</ol>

<p>To achieve fairness, the POBI protocol states that the TEE can generate one random nonce each round, and the winner of a round is the Aggregator whose TEE generates the lowest random number from the group. The TEEs generate these numbers independently and then gossip them. The Aggregators who do not win the round, similar to L1 miners, respect this decision because it is rational to do based on the incentive mechanism. If they choose to not respect the protocol, they are free to submit a losing rollup to the L1, which is ignored by all compliant Aggregators, meaning such an Aggregator has to pay L1 gas and not get any useful reward.</p>

<p>The second goal is achieved by linking the random nonce generation, which terminates a round, to the Merkle proof of inclusion of the parent rollup (which exists as a transaction in the L1 transaction Patricia trie) in an L1 block. This property is what gives the name of the protocol. This means that an Aggregator can obtain a signed rollup from the TEE only if it can show the rollup is based on a published rollup in a prior L1 block. Furthermore, this feature links the creation of L2 rollup to an L1 block, thus synchronising their cadence.</p>

<p>A party wishing to increase its chances of winning rounds must register multiple Aggregators and pay the stake for each. The value of the stake needs to be calculated in such a way as to achieve a right decentralisation and practicality balance.</p>

<p>It is straightforward for all the other Aggregators to verify which rollup is the winner by comparing the nonces and checking that the rollup signature is from an approved Aggregator.</p>

<p>Note that the L1 Management Contract is not checking the nonces of the submitted rollups, but it checks that the block inclusion proof is valid. The L1 contract rejects rollups generated using a proof of inclusion that is not an ancestor of the current block.</p>

<p>A further issue to solve is to ensure that the host cannot repeatedly submit the proof to the TEE to try to get a lower nonce, explained <a href="#preventing-repeated-random-nonce-generation">here</a>.</p>

<h2 id="typical-scenario">Typical Scenario</h2>
<ol>
  <li>A new round starts from the point of view of an Aggregator when it decides that someone has gossiped a winning rollup. At that point, it creates a new empty rollup structure, points it to the previous one, and starts adding transactions to it (which are being received from users or by gossip).</li>
  <li>In the meantime, it closely monitors the L1 by being directly connected to an L1 node.</li>
  <li>As soon as the previous rollup was added to a mined L1 block, the Aggregator takes that Merkle proof, feeds it to the TEE, who replies with a signed rollup containing a random nonce generated inside the enclave.</li>
  <li>All the other Aggregators do roughly the same thing at the same time.</li>
  <li>At this point (which happens immediately after successfully publishing the previous rollup in the L1), every Aggregator has a signed rollup with a random nonce which they gossip between them. The party with the lowest nonce wins. All the Aggregators know this, and, after a short waiting period, a new round starts.</li>
  <li>The winning Aggregator has to create an Ethereum transaction that publishes this rollup to L1.</li>
</ol>

<p>Note that by introducing the requirement for proof of inclusion in the L1, the cadence of publishing the rollups to the block times is synchronised. Also, note that the hash of the L1 block used to prove to the TEE that the previous rollup was published is added to the current rollup such that the Management Contract and the other Aggregators know whether this rollup was generated correctly.</p>

<p>The following diagram depicts this sequence:
<img src="./images/node-processing.png" alt="node-processing" /></p>

<h2 id="notation">Notation</h2>
<p>There are six elements that define a rollup :</p>

<ol>
  <li>The rollup parent.</li>
  <li>The rollup height (Nth generation).</li>
  <li>The Aggregator who generated it.</li>
  <li>The height of the L1 block used as proof (L1_Proof_Height).</li>
  <li>The height of the L1 block that includes this rollup (L1_Block_Height).</li>
  <li>The nonce.</li>
</ol>

<p>The following diagram depicts these elements:
<img src="./images/block-elements.png" alt="block elements" /></p>

<p>The notation is the following: <em>R</em>$Rollup_Height[$Aggregator, L1<em>Proof_Height, L1_Block_Height, $Nonce]</em>.</p>

<p>Note that the value of <em>L1_Proof_Height</em> can only be lower than <em>L1_Block_Height</em>.</p>

<p>Example: <em>R_15[Alice, 100, 102, 20]</em> means the rollup height is 15, the aggregator is <em>Alice</em>, the height of the L1 block used as proof is 100, the height of the L1 block that included the rollup is 102, and the nonce equals 20.</p>

<h2 id="the-canonical-chain">The Canonical Chain</h2>
<p>The POBI protocol allows any Aggregator to publish rollups to the Management Contract, so short-lived forks are a normal part of the protocol. The forks cannot be long-living during normal functioning because the TENVM running inside the TEE of every node deterministically selects one of the forks as the canonical chain and only appends a rollup on top of that.</p>

<p>Because the logic is identical and attested on all nodes and the TEEs receive all the relevant content of the L1 blocks (which means they process the same input data), there cannot be any competing forks more than one rollup deep unless there is a hack.</p>

<p>The rules for the canonical chain are the following:</p>
<ol>
  <li>The genesis rollup is part of the canonical chain and will be included in an L1 block by the first Aggregator.</li>
  <li>An L1 block containing a single rollup whose parent is the head rollup of the canonical chain included in a previous L1 block is on the canonical chain if no other rollup with the same parent was included in an earlier block. Any other sibling rollup included in a later block is not on the canonical chain. This is the <em>Primogeniture</em> rule, where a rollup is born when included in an L1 block.</li>
  <li>If an L1 block contains multiple sibling rollups created in the same round using the same L1 proof, the one with the lower nonce is on the canonical chain.</li>
  <li>If an L1 block contains multiple sibling rollups created using different L1 proofs, the one created using the more recent proof is on the canonical chain.</li>
</ol>

<p>Using the notation, for the same <em>Rollup_Height</em>, the rollup on the canonical chain is the one with:</p>
<ol>
  <li>The lowest L1_Block_Generation.</li>
  <li>In case there are multiple matches, use the highest L1_Proof_Generation.</li>
  <li>In case there are multiple matches, use the lowest nonce.</li>
</ol>

<p>Given that the nonce is a random number with sufficient entropy, we assume there cannot be a collision at this point during normal functioning. In the situation where it happens, the rollup on the canonical chain will be the one with the lowest hash.</p>

<h2 id="preventing-repeated-random-nonce-generation">Preventing Repeated Random Nonce Generation</h2>
<p>In phase 3 of the protocol, the TEE of each Aggregator generates a random nonce which determines the winner of the protocol. This introduces the possibility of gaming the system by restarting the TEE and generating multiple numbers.</p>

<p>The solution proposed by TEN is to introduce a timer in the constructor upon every startup of the enclave. A conventional timer, based on the clock of the computer, is not very effective since the host can game it. Instead, the enclave must calculate serially (on a single thread) a large enough number of SHA256 hashes, which it would not be able to do faster than an average block time even on powerful hardware.</p>

<p>This solution is effective since the code is attested and does not rely on any input from the host.</p>

<p>A node operator wanting to cheat would restart the enclave and quickly feed it the proof of inclusion, only for the enclave to process it after 15 seconds, which means the operator has already missed the time window for that rollup.</p>

<p>This built-in startup delay is also useful in preventing other real-time side-channel attacks, which could be used for MEV.</p>

<h2 id="aggregator-incentives">Aggregator Incentives</h2>
<p>All successful decentralised solutions need a robust incentive mechanism to keep the protocol functioning effectively.</p>

<p>Compared to a typical L1 protocol, there is an additional complexity to consider. In an L1 like Bitcoin or Ethereum, once a node gossips a valid block, all the other nodes are incentivised to use it as a parent because they know everyone does that too. In an L2 decentralised protocol like POBI, there is an additional step: the publication of the rollup to L1, which can fail for multiple reasons. Furthermore, the incentive design must also consider the problem of front-running the actual rollup. For a rollup to be final, it has to be added to an L1 block, which is where an L1 miner or staker can attempt to claim the reward that rightfully belongs to a different L2 node.</p>

<p>Note that rollup finality will be covered extensively in the <a href="./ten-ethereum-interaction">TEN - Ethereum interaction section</a>.</p>

<p>The high-level goal is to keep the system functioning as smoothly as possible and resist random failures or malicious behaviour while not penalising TEN nodes for not being available. We believe that penalties for availability increase the barrier of entry, and thus make the system centralised over the long term.</p>

<p>TEN introduces the concept of <em>claiming rewards</em> independently of the actual canonical rollup chain. The great advantage is increased flexibility in aligning incentives at the cost of increased complexity. Rewards can be awarded in full, split between Aggregators or just enough to cover the cost of gas.</p>

<p>To achieve this, the protocol has to maintain a pool of tokens. Users will pay fees into this pool, while nodes will be paid from it. During bootstrapping, the protocol will have the ability to add newly minted tokens to the pool. Once the network picks up, the protocol will be able to burn excess tokens.</p>

<p>Note, that an important assumption is that the reward from publishing a rollup will never exceed twice the gas cost.</p>

<p>These are the Aggregator rewarding rules:</p>

<ol>
  <li>
    <p>The first Aggregator to successfully published a rollup without competition in an L1 block will get the full reward. This is the most efficient case that is encouraged.
<em>Note: Competition means another rollup with the same parent.</em></p>
  </li>
  <li>If multiple rollups generated with the same L1 proof and different nonces are published in the same block (the target block), the one with the lowest nonce is on the canonical chain, but the reward is split between them in a proportion of 75/25 (this ratio is indicative only). The reason for this rule is that it incentivises Aggregators to gossip their winning rollup such that no one else publishes at the same time.
    <ul>
      <li>There is no incentive for the losing Aggregator to publish as 25% of the reward will not cover the cost of gas, so they will make a loss.</li>
      <li>There is an incentive for the winning Aggregator to gossip the rollup to everyone else to avoid having this unwanted competition.</li>
      <li>In case of a genuine failure in gossip (i.e. beyond designed latency), the losing Aggregator receives something. This is to reduce the risk of Aggregators waiting more than necessary to receive messages from all the other Aggregators.</li>
    </ul>
  </li>
  <li>
    <p>If multiple sibling rollups generated using different L1 blocks as proof are included in the same block, the one created with the most recent proof receives the full reward.</p>

    <p>The original winning rollup that did not get published immediately does not receive any reward since more recent competition exists. This rule is designed to encourage publishing with enough gas, such that there is no risk of competition in a further block. The rule also encourages Aggregators to not wait for rollups published with insufficient gas or not at all.</p>

    <p>This mechanism ensures rounds reset when new L1 blocks are available and the reward is up for grabs. An actor controlling multiple Aggregators with malicious irrational behaviour can only slow down the ledger because the rational actors will publish the rounds they win.</p>
  </li>
  <li>
    <p>If two consecutive L1 blocks include each a rollup with the same height created from the same L1 proof, but the rollup from the second block has a lower nonce, split the reward evenly between the two Aggregators.</p>

    <p><em>Note that the rollup with the higher nonce is on the canonical chain.</em></p>

    <p>The reason for this rule is that this scenario is possibly the result of rollup front-running, which is thus discouraged as the frontrunner is consuming precious Ethereum gas and the reward will always be less than the cost.</p>

    <p>The even splitting of the reward also encourages the Aggregator that wins a nonce generation round to publish as soon as possible, because publishing a block later will at best result in a small loss.</p>
  </li>
  <li>If two sibling rollups created from the same L1 proof are published more than one block apart, where the first published rollup has a higher nonce, then pay the reward in full to the first published rollup. The reason for this rule is that the winner most likely added too little gas, and someone else spotted the opportunity and contributed to earlier finality, which is rewarded. It adds an incentive to monitor gas prices and pay enough to ensure their rollup is published.</li>
</ol>

<p>The following diagrams depict some of the rewarding rules:
<img src="./images/block-rewarding.png" alt="l1 rewarding" /></p>

<p>The following diagram depicts rules in the case of front-running:
<img src="./images/block-frontrunning.png" alt="l1 front running" /></p>

<p>This is python-like pseudocode to calculate the rewards that can be claimed by an <em>Aggregator</em> for a <em>Rollup_Height</em>. Note that it is not comprehensive, and there may be many competing aggregators.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The rollup height for which we calculate the rewards
</span><span class="n">height</span> <span class="o">=</span> <span class="n">N</span>

<span class="c1"># 'heightN_L1_Blocks' is a list of all L1 blocks starting with the _L1_Block_Height_ of the head 
# of the canonical chain of the previous generation, until the block where you encounter the 
# first valid rollup of _Rollup_Height_ plus one extra L1 block.
</span><span class="n">heightN_L1_Blocks</span> <span class="o">=</span> <span class="n">calculateBlocks</span><span class="p">()</span>

<span class="c1"># List of rollups of height N found in the last block
</span><span class="n">rollups_in_last_block</span> <span class="o">=</span> <span class="n">heightN_L1_Blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">rollups</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">height</span> <span class="o">==</span> <span class="n">height</span><span class="p">)</span>

<span class="c1"># List of rollups of height N found in the target block
</span><span class="n">rollups_in_target_block</span> <span class="o">=</span> <span class="n">heightN_L1_Blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">].</span><span class="n">rollups</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">height</span> <span class="o">==</span> <span class="n">height</span><span class="p">)</span>

<span class="k">if</span> <span class="n">rollups_in_target_block</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">rollups_in_last_block</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

    <span class="c1"># There is no competition for the target rollup
</span>    <span class="n">fullRewardTo</span><span class="p">(</span><span class="n">rollups_in_target_block</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">aggregator</span><span class="p">)</span>

<span class="k">elif</span> <span class="n">rollups_in_target_block</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">rollups_in_last_block</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

    <span class="c1"># There is competition for the target rollup in the next rollup
</span>    <span class="c1"># Which means there is suspicion of frontrunning
</span>    <span class="n">target_rollup</span> <span class="o">=</span> <span class="n">rollups_in_target_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">competition_rollup</span> <span class="o">=</span> <span class="n">rollups_in_last_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
   
    <span class="k">if</span> <span class="n">competition_rollup</span><span class="p">.</span><span class="n">L1_Proof_Height</span> <span class="o">==</span> <span class="n">target_rollup</span><span class="p">.</span><span class="n">L1_Proof_Height</span> <span class="ow">and</span> <span class="n">competition_rollup</span><span class="p">.</span><span class="n">nonce</span> <span class="o">&lt;</span> <span class="n">target_rollup</span><span class="p">.</span><span class="n">nonce</span><span class="p">:</span>
        <span class="c1"># This is possibly front-running or failure to gossip
</span>        <span class="c1"># All parties involved in this will make a small loss
</span>        <span class="n">partialRewardTo</span><span class="p">(</span><span class="n">target_rollup</span><span class="p">.</span><span class="n">aggregator</span><span class="p">,</span> <span class="s">'50%'</span><span class="p">)</span>
        <span class="n">partialRewardTo</span><span class="p">(</span><span class="n">competition_rollup</span><span class="p">.</span><span class="n">aggregator</span><span class="p">,</span> <span class="s">'50%'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The target has the lower nonce or is generated with a different proof
</span>        <span class="n">fullRewardTo</span><span class="p">(</span><span class="n">target_rollup</span><span class="p">.</span><span class="n">aggregator</span><span class="p">)</span>

<span class="k">elif</span> <span class="n">rollups_in_target_block</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="c1"># Two competing rollups in the target block
</span>    <span class="c1"># This is not a front-running situation, so eventual rollups published in the next block do not matter
</span>    <span class="n">rollup1</span> <span class="o">=</span> <span class="n">rollups_in_target_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rollup2</span> <span class="o">=</span> <span class="n">rollups_in_target_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">rollup1</span><span class="p">.</span><span class="n">L1_Proof_Height</span> <span class="o">==</span> <span class="n">rollup2</span><span class="p">.</span><span class="n">L1_Proof_Height</span><span class="p">:</span>

        <span class="c1"># According to rule #2 the competing rollups will split the reward 
</span>        <span class="k">if</span> <span class="n">rollup1</span><span class="p">.</span><span class="n">nonce</span> <span class="o">&lt;</span> <span class="n">rollup2</span><span class="p">.</span><span class="n">nonce</span><span class="p">:</span>
            <span class="n">partialRewardTo</span><span class="p">(</span><span class="n">rollup1</span><span class="p">.</span><span class="n">aggregator</span><span class="p">,</span> <span class="s">'75%'</span><span class="p">)</span>
            <span class="n">partialRewardTo</span><span class="p">(</span><span class="n">rollup2</span><span class="p">.</span><span class="n">aggregator</span><span class="p">,</span> <span class="s">'25%'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">partialRewardTo</span><span class="p">(</span><span class="n">rollup1</span><span class="p">.</span><span class="n">aggregator</span><span class="p">,</span> <span class="s">'25%'</span><span class="p">)</span>
            <span class="n">partialRewardTo</span><span class="p">(</span><span class="n">rollup2</span><span class="p">.</span><span class="n">aggregator</span><span class="p">,</span> <span class="s">'75%'</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">rollup1</span><span class="p">.</span><span class="n">L1_Proof_Height</span> <span class="o">&gt;</span> <span class="n">rollup2</span><span class="p">.</span><span class="n">L1_Proof_Height</span><span class="p">:</span>

        <span class="c1"># According to rule #3 the rollup generated with the more recent proof gets the reward 
</span>        <span class="n">fullRewardTo</span><span class="p">(</span><span class="n">rollup1</span><span class="p">.</span><span class="n">aggregator</span><span class="p">)</span>
   
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># According to rule #3 the rollup generated with the more recent proof gets the reward 
</span>        <span class="n">fullRewardTo</span><span class="p">(</span><span class="n">rollup2</span><span class="p">.</span><span class="n">aggregator</span><span class="p">)</span>
        
<span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p><em>Note that these rules are subject to adjustment based on production observations.</em></p>

<h2 id="rollup-evolution">Rollup Evolution</h2>
<p><img src="./images/block-rollup-complex.png" alt="block rollup complex" /></p>

<h1 id="detailed-technical-design">Detailed Technical Design</h1>
<p>This section describes key TEN component designs.</p>

<h2 id="cryptography">Cryptography</h2>
<p>This section covers the various cryptographic techniques used by TEN.</p>

<h3 id="master-seed">Master Seed</h3>
<p>CPU manufacturers provision every TEE with one or multiple keys, the <em>Enclave Key</em> (EK). These keys are used for digitally signing messages and identifying a TEE. They are also used for encrypting data that only that particular hardware TEE can decrypt. To achieve the goals of a collaborative, decentralised network like TEN, all the TEEs have to work on the same set of transactions, which means they must all decrypt them.</p>

<p>The first enclave, called the <em>Genesis Enclave</em>, generates a 256bit random byte array called the <em>Master Seed</em> inside the encrypted memory space. It encrypts this seed with the <em>EK</em> and sends it to the Management Contract to be stored there, as well as storing it locally on the host server.</p>

<h3 id="sharing-the-master-seed">Sharing the Master Seed</h3>
<p>After proving their attestation, subsequent nodes receive that secret <em>Master Seed</em> encrypted with their key. The medium over which they receive the data is the Management Contract to ensure maximum data availability.</p>

<p>Before obtaining the shared secret, the L2 nodes must attest that they are running a valid version of the contract execution environment on a valid CPU.</p>

<p><em>Note: The solution assumes that attestation verification can be implemented efficiently as part of the  Management Contract. This is the ideal solution since it makes the contract the root of trust for the L2 network.</em></p>

<p>The sequence for node registration is shown in the following diagram:
<img src="./images/node-registration.png" alt="node registration" /></p>

<p>An L2 node invokes a method on the Management Contract to submit their attestation, verifying it and saving this request. Then, another L2 node (which already holds the secret key inside its enclave) responds by updating this record with the shared secret encrypted using the public key of the new TEE. Whichever existing L2 node replies first, signed by the enclave to guarantee knowledge of the secret, receives a reward.</p>

<p><em>Note: This solves several problems; the Management Contract provides a well-known central registration point on the Ethereum network, which can store the L2 shared secret in public with very high availability, and existing L2 nodes are compensated for their infrastructure and L1 gas costs to onboard new nodes.</em></p>

<h3 id="generating-keys">Generating Keys</h3>
<p>The TEEs use the shared secret to generate further asymmetric and symmetric keys used by users to encrypt transactions and by the enclaves themselves to encrypt the content of the rollups.</p>

<p>Each enclave uses this master entropy to generate additional keys deterministically:</p>

<ol>
  <li>A public/private key pair is used as the identity of the network. The public key is published to L1 and used by clients to encrypt the signed TEN transactions and is referred to as <em>TEN_Public_Key</em></li>
  <li>A set of symmetric keys used by the TEEs to encrypt the transactions which will stored on the L1 blockchain in rollups.</li>
</ol>

<p><em>Note: When submitting a rollup, each enclave signs it with the key found in their attestation (the _AK</em>)._</p>

<h3 id="transaction-encryption">Transaction Encryption</h3>
<p>One of the explicit design goals of TEN is to help application developers achieve their privacy requirements while giving them the tooling to disincentivise their users from using the application for illegal behaviour such as money laundering.</p>

<p>When deploying a contract to TEN, the developer has to choose one of the predefined revealing options:</p>

<ul>
  <li><em>XS</em> - 12 seconds (1 block)</li>
  <li><em>S</em> - 1 hour (3600/12 = 300 blocks)</li>
  <li><em>M</em> - 1 day (24 * 3600/12 = 7200 blocks)</li>
  <li><em>L</em> - 1 month</li>
  <li><em>XL</em> - 1 year</li>
</ul>

<p><em>Note: These periods are counted in L1 blocks and are indicative.</em></p>

<p>One of these options is chosen by default for applications that do not explicitly specify one. Based on the chosen period, transactions submitted to that application can be decrypted by anyone after that time delay.</p>

<p>The protocol deterministically derives 5 symmetric encryption keys for each rollup, derived from the master seed, the reveal option, the running counter for that option, and the block height, such that all TEEs in possession of the master secret can calculate the same encryption key.</p>

<p>For example, application <em>FooBar</em> has a reveal setting of <em>M</em> (1 day). Alice submits a transaction (encrypted with the <em>TEN_Public_Key</em>) <em>Tx1</em> on the 1st of February and another <em>Tx2</em> on the 2nd of February. Inside the TEE, they are decrypted and executed. When the rollup is generated, all transactions sent to applications with the same reveal option are bundled together by the Aggregator, compressed, and encrypted with the <em>Encryption_Key(Master_Seed, Reveal_Option, Counter, Block_Height)</em>.</p>

<p>The transaction blob is formed by concatenating all the encrypted intervals without any delimiter to prevent information from leaking. Then, separately from the transaction blob, a data structure is created containing each option’s start (index) position. This map is also added to the rollup after being encrypted with a separate key that is not revealed.</p>

<p>This is depicted in the following diagram:
<img src="./images/encryption-options.png" alt="encryption options" /></p>

<p><em>Note that the predefined reveal periods are preferable to each application choosing a custom period, as it simplifies computation and the number of keys that have to be managed.</em></p>

<h3 id="revelation-mechanism">Revelation Mechanism</h3>
<p>The mechanism described above ensures that TEN transactions are encrypted with different keys, which can be revealed independently.</p>

<p>The other piece of the puzzle is the mechanism that controls the actual reveal process. On a high level, the platform needs a reliable way to measure the time that cannot be gamed by a malicious host owner.</p>

<p>The L1 blocks can be used as a reliable measure of average time. The rule is that after enough blocks have been added on top of the block that includes the rollup with the encrypted transactions, any user can request the encryption key and the position of the transactions they are entitled to view from the TEE of any TEN node.</p>

<p>A malicious node operator wanting to have a peek at transactions before the designated time has passed can try to <em>fast-forward</em> time by creating an Ethereum fork and mining blocks with well-chosen timestamps such that difficulty keeps decreasing.</p>

<p>The solution to this problem is straightforward. TEN TEEs fully understand the Ethereum protocol and receive all L1 blocks as part of the POBI protocol, which allows them to verify that the blocks are valid, but they cannot know wheter this is the canonical Ethereum chain or a malicious fork designed to fast-forward time. To address this, TEN hard-codes a minimum difficulty lower than the average network difficulty for the last year, but much higher than any single actor can achieve. This will prevent the node operator from speeding up time.</p>

<h3 id="cryptographic-algorithms">Cryptographic Algorithms</h3>
<p>TEN makes the same choices as Ethereum for hashing and signing algorithms and uses the same elliptic curve.</p>

<p>Communication with TEEs and the encryption algorithms are not yet defined.</p>

<p><em>Note: There might be a more efficient way to achieve the same high-level goals, and we are considering different other options.</em></p>
<h2 id="state">State</h2>
<p>TEN is an account-based L2 decentralised ledger system similar to the L1 Ethereum blockchain, where the state is calculated independently by each node based on the canonical list of transactions and stored as a <em>Patricia Trie</em> in each rollup. Each node processes all prior transactions to establish the current state (full sync), and optimised sync methods (e.g. fast sync) will likely be supported. One significant difference is that the account balances can only be calculated inside the TEEs and are only revealed under certain conditions. The model is not described further in this paper because it is the same as <a href="https://ethereum.org/en/developers/docs/accounts/">Ethereum Accounts</a>.</p>

<p>The transaction and smart contract formats are similar to Ethereum, with a few differences introduced by the confidentiality requirements.</p>

<h3 id="smart-contracts-and-the-ten-vm">Smart Contracts and the TEN VM</h3>
<p>TEN application developers will write smart contracts in a familiar programming language using familiar blockchain tools and abstractions.
Due to data privacy concerns, existing smart contracts will have to change before deploying them to TEN.</p>

<p>To implement these requirements, TEN supports a runtime largely compatible with the <em>Ethereum Virtual Machine</em> (EVM) and is derived from an existing implementation such as <a href="https://github.com/ethereum/go-ethereum">Geth</a>, the canonical client of the Ethereum protocol.</p>

<p>On a high level, the <em>TEN Virtual Machine</em> (OVM) will be almost identical to the EVM, but there are significant differences behind the scenes between the data structures used by Ethereum and the ones used by TEN. The rollup structure also differs significantly from the Ethereum block structure as it contains encrypted transactions, plaintext withdrawal instructions, plaintext events, references to L1 blocks, and more. The OVM will eventually introduce new abstractions and primitives to reflect the data privacy requirements and implement data isolation where it is needed. One last significant difference from the EVM is the implementation of the TEN cryptography requirements.</p>

<h3 id="state-confidentiality-between-smart-contracts">State Confidentiality between Smart contracts</h3>
<p>The main goal of TEN is to protect user data. If smart contracts were wholly isolated from each other, it would be easy to define data access rules.</p>

<p>Contract composition introduces significant complexity. DeFi enjoys massive success thanks to the ability of contracts to be combined in serendipitous ways not predicted by the contract creator, and TEN intends to replicate that.</p>

<p>For example, one contract might have been written to reveal information for the caller’s eyes only in an encrypted response. But if the caller is another contract, that wrapping contract might turn the response into a public broadcast event, visible to everyone.</p>

<p>This area is still under active research. The first version of TEN will rely on application developers to check programmatically who can call different functions and what data they should receive, and therefore developers should reason about what could happen if their contract is called by a contract that they don’t control.</p>

<p>For subsequent versions, TEN explores the following concepts:</p>
<ul>
  <li>Each contract can declaratively whitelist contracts that can access different functions.</li>
  <li>Automatically propagate access. For example, if <em>Account.getBalance()</em> can be invoked only by the owner, it means that any contract that invokes this has to originate from a message signed by the owner. This solution sounds appealing, but it needs more research to determine if this mechanism prevents useful use cases.</li>
</ul>

<h3 id="wallets-and-transaction-submission">Wallets and Transaction Submission</h3>
<p>User wallets create transactions encrypted with the <em>TEN public key</em>. Only valid TEEs (i.e. Aggregators and Verifiers) in possession of the Master Seed can decrypt, execute, and see the resulting state. Still, end-users who submitted a transaction must be able to receive the result and query the balance.</p>

<p>A traditional wallet connected to a node on a public blockchain can read the balance of any account and display it to the user. For a similar user experience, TEN-enabled wallets need to submit signed requests to L2 nodes and receive responses that they can display to the user. The responses need to be encrypted with the user key and have to be cryptographic proofs linking the balance to a rollup.</p>

<p>Validity verification of such proofs can be done by first checking the TEE signature and then by checking that the rollup is on the canonical chain of both the L2 and the L1 chains.</p>

<h3 id="smart-contract-types">Smart Contract Types</h3>
<p>Since all data is temporarily private, and smart contracts are just data, the TEN model supports two types of smart contracts.</p>

<ul>
  <li>
    <p><em>Public contracts</em>, which are equivalent to the Ethereum smart contracts in the sense that the source code will be available online, and anyone can build them and compare the hash of the bytecode against the address they are sending commands to.</p>
  </li>
  <li>
    <p><em>Private contracts</em>, for which the developer has not published the source code. These can be used for custom logic like arbitration where the developer intends to keep the profit making strategy hidden from competitors.</p>
    <h2 id="l1-contracts">L1 Contracts</h2>
    <p>On the L1 network, several conventional Ethereum contracts act together to form a Management Contract.</p>
  </li>
</ul>

<h3 id="network-management-1">Network Management</h3>
<p>This contract is the gatekeeper for the protocol. Therefore, any node wishing to join TEN must interact with this contract and prove it is valid.</p>

<ul>
  <li>It registers L2 nodes, verifies their TEE attestation, and manages their stakes. (Stakes are required for the Aggregators who publish rollups as an incentive to follow the protocol.)</li>
  <li>It manages the TEE attestation requirements. This means that the governance of the contract can decide which enclave code is approved to join.</li>
  <li>It manages the L2 TEEs’ shared secret key to be available in case of L2 node failure. The L1 acts as the ultimate high availability storage. Note: This is expanded in the <a href="./cryptography">Cryptography</a> section.</li>
  <li>It keeps a list of URLs (or IP addresses) for all Aggregators. The use of URLs allows for the underlying IP address to be changed. Verifiers do not stake, and are not a gossip recipient, so their address is not recorded, but they must register in order to attest a correct TEE and to be able to collect rewards.</li>
</ul>

<h3 id="rollup-management-1">Rollup Management</h3>
<p>This contract interacts with the Aggregators.</p>

<ul>
  <li>It determines whether to accept blocks of transactions submitted by an L2 node. The Rollup contract can only accept a rollup from an Aggregator with a stake and valid attestation, and it checks that the signature of the rollup generated in the TEE matches the TEN_Public_Key registered by the L2 node.</li>
  <li>It stores the encrypted L2 transactions in an efficient format.</li>
</ul>

<h3 id="bridge-management">Bridge Management</h3>
<p>This contract is essential for the solution’s security since all value deposited by end-users is locked in this bridge.</p>

<ul>
  <li>It acts as a pool where people can deposit assets, like fungible or non-fungible ERC tokens, made available as wrapped tokens to use on the TEN network and can be withdrawn on demand back to an L1.</li>
  <li>In case of conflicting forks in the rollup chain, it must delay withdrawals until one fork expires or enter a procedure to discover which fork is valid. This is covered in more detail in <a href="./ten-ethereum-interaction#withdrawals">Withdrawals</a>.</li>
  <li>It may be extended to manage liquidity yields.</li>
</ul>

<h1 id="ten-and-ethereum-interaction">TEN and Ethereum Interaction</h1>
<p>TEN is a confidential extension to Ethereum, and thus assets have to move freely between the two networks.</p>

<p>All sidechains and L2 solutions have developed solutions to the mismatches between the different models of the two networks, and typically there is a bridge contract that safeguards assets.
The difference between sidechains and L2 solutions is that mismatches are more significant for sidechains because they have their own finality and security mechanisms, and thus the bridge logic is either very complex or centralised.</p>

<h2 id="deposits">Deposits</h2>
<p>The user deposits supported ERC tokens into the well-known address of the Bridge contract, and once the transaction is successfully added to a block, the TEN-enabled wallet automatically creates an L2 transaction, including proof of the L1 transaction. The exact amount is credited with wrapped tokens on the user’s account on TEN.</p>

<p>The fact that the finality of L1 transactions is probabilistic makes crediting the L2 account not straightforward. Most solutions solve this problem by waiting for a confirmation period before crediting the account. TEN takes a different approach and introduces a dependency mechanism between the L2 rollup and the L1 blocks.</p>

<p>The rule is that the L2 rollup that includes the transaction that credits the TEN account has a hard dependency on an L1 block, and the Bridge contract enforces that it is one of the ancestors of the current block. If the L1 deposit transaction is no longer in the canonical L1 chain, it automatically invalidates the rollup that contains the L2 deposit transaction, and the L1 deposit will only be recognised as the basis for an L2 rollup credit transaction when it has been included in the canonical L1 chain.</p>

<p>The interaction is shown in the following diagram:
<img src="./images/user-registration.png" alt="user registration" /></p>

<p>See also the <a href="./appendix#data-model">Data model</a> section and the following dependency diagram.
<img src="./images/deposit-process.png" alt="deposit process" /></p>

<p><em>Note: The deposit L2 transaction cannot be fully encrypted because the Aggregator has to decide whether to include it in the current rollup based on the chances of the L1 block it depends on being final.</em></p>

<h2 id="withdrawals">Withdrawals</h2>
<p>The high-level requirement for the withdrawal function is simple: allow TEN users to move assets back into the Ethereum network. The problem is that this is where the most significant threat against such a solution lies because there might be a large amount of locked value.</p>

<p>The challenge is to implement this functionality in a decentralised way by defining a protocol and economic incentives.</p>

<p>Due to the sensitivity of this function, many sidechains and L2 solutions rely on multi-signature technology to control the release of funds. Optimistic Rollups rely on a challenge mechanism during a long waiting period before releasing funds, powered by economic incentives.</p>

<p>TEN uses TEE technology, but it cannot leverage it for this aspect because of our threat model. The Bridge Contract could release funds based on a signature from an attested TEE if it were invulnerable, but since that is not the case, the solution is to use economic incentives on top of the POBI protocol.</p>

<h3 id="rollup-finality">Rollup Finality</h3>
<p>The general rule is that withdrawals can be processed only when a rollup is <em>final</em>. This means this is the protocol for the finality of the TEN chain relative to the Ethereum chain.</p>

<h4 id="rule-1---the-standard-delay-period">Rule 1 - The standard delay period</h4>
<p>In the usual case, a rollup from the canonical chain (see POBI protocol) is final if a standard number of blocks corresponding to a period of 1 day has passed from the Ethereum block where it was published.</p>
<ul>
  <li>Note 1: The period is measured in Ethereum blocks because the delay is stable on average between blocks.</li>
  <li>Note 2: The reason for this period is to give honest nodes the chance to “challenge” the rollup if it is malicious.</li>
  <li>Note 3: The period is inverse to the number of L2 nodes. It should be long enough to give honest participants the chance to react and publish in the face of aggressive censorship attempts against them, but short enough not to degrade the user experience. We estimate that once the network reaches a healthy number of nodes, we can reduce it to 50-100 blocks (~ 10 minutes).</li>
</ul>

<h4 id="rule-2---the-competing-forks">Rule 2 - The competing forks</h4>
<p>Assuming the period chosen at rule #1 is enough, the only possible write attack performed by an actor that could hack the TEE manifests as multiple parallel forks at least two rollups deep. This is because all valid TEEs run the same attested code that chooses the same canonical chain from the rollups published in the L1 block presented as proof. If the Management Contract notices multiple forks, the rule is that finality is suspended on all forks, thus, withdrawals are suspended. Likewise, if one of the forks becomes inactive, the rule is that all rollups on the alive fork become final once a standard period of 1 day has passed from the last L1 block that contained a rollup published on the inactive branch.</p>

<ul>
  <li>Note1: This rule degrades a <em>write-attack</em> into a Denial of Service attack on the withdrawal function.</li>
  <li>Note2: Assuming there are honest participants, the actual canonical ledger keeps growing, including user transactions.</li>
  <li>Note3: The attacker has to spend Ethereum gas to keep the malicious fork alive.</li>
</ul>

<h4 id="rule-3---addressing-the-dos-on-finality">Rule 3 - addressing the DoS on finality</h4>
<p>Since rule #2 transforms any attack into a DoS attack, the protocol has some mechanisms to keep user experience satisfactory even in the extreme case of a TEE hack.</p>

<ol>
  <li>
    <p>The ultimate backstop is the “Attestation Constraints” rules. Forks in the canonical chain are clearly a breach of protocol, caused either by a TEE hack or a protocol hack. This is ultimately resolved with software or, at worst, hardware updates. Once the management Contract forces an upgrade, the attacker will no longer be able to create malicious rollups, and thus the fork becomes inactive, and finality resumes on the valid fork.</p>
  </li>
  <li>
    <p>For any users with an L2 node, it is obvious which is the canonical chain, as it is the one that does not fail. Market makers operating on both L1 and L2 can step in and absorb the withdrawal requests of users at a slight discount without taking any actual risk.</p>
  </li>
</ol>

<p>The above rules will, in practice, prevent this type of attack, and if it happens, offer a practical solution for users. In addition, the protocol has yet another backstop to address the extreme case of a very persistent attacker.</p>

<p>The network governance model allows any user to trigger the <em>forced finality procedure</em> by staking or voting on one of the competing rollup chains. The minimum stake is a percentage of the amounts being withdrawn on that branch, set through governance. Backers of the other chain are obliged to stake a similar or higher value to compete. The decision process is run as an auction, where the party that loses also loses their bids. When concluded, all rollups on that chain are considered final, and withdrawals are executed.</p>

<h3 id="withdrawals-protocol">Withdrawals protocol</h3>
<p>Each TEE signed rollup contains a plaintext list of withdrawal requests. See: <a href="./appendix#data-model">Data Model</a>.</p>

<p>The Bridge contract keeps track of these requests and executes them at different times, based on the finality status of that rollup.</p>

<p>The withdrawal process is indicated in the following diagram:
<img src="./images/withdrawal-process.png" alt="withdrawal process" /></p>

<h2 id="ten-public-events">TEN public events</h2>

<p>Ethererum application developers can use a confidential L2 like TEN for some jobs that are not possible otherwise.</p>

<p>For example, an L1 smart contract organises a fair lottery that needs a reliable random number generator that the miners cannot game.</p>

<p>Another example is publishing the result of a poker game played inside TEN, which the L1 contract can use to make a payment or update the tournament results.</p>

<p>The challenge for achieving this functionality is that the data originating in L2 has to be final.
Luckily TEN has this mechanism already in place for processing withdrawals.
Applications running inside TEN can emit special types of events called <em>Public Events</em>, which the OVM will add in plaintext into a dedicated data structure in the rollup.
The _Rollup Contract _ first processes the rollup, and then once they reach finality, it exposes these events to external contracts.</p>

<p>Note: The fair lottery can be implemented in two steps to avoid any possible influence. The implementation can use the submarine technique and first publish the hash of that number in an event, and a few blocks later publish the actual number in a different event.</p>

<h1 id="threat-model">Threat Model</h1>
<p>TEN is different from traditional L1 or L2 solutions primarily because data is stored and processed privately in trusted execution environments, which brings a new set of threats. Compared to other L2 solutions, the decentralised nature of the POBI protocol also brings some new threats.</p>

<p>The main threat to any ledger technology is data corruption, also known as a safety failure. It could take the form of stealing assets, double spending assets, or, more generally, adding illegal entries. Leading blockchains solve this problem by implementing a <em>Byzantine Fault Tolerant</em> (BFT) consensus between independent parties and creating incentives to ensure that anyone who breaks the rules will not be rewarded or will even be penalised. The most extreme attack is a 51% <em>Sybil</em> attack, where the attacker somehow gains the majority of the decision power (computing power for <em>proof of work</em> or stake for <em>proof of stake</em>) and can rewrite the history. This attack manifests as replacing an existing valid transaction with a valid competing transaction. While the ledger remains <em>logically</em> valid, this is equivalent to stealing for the beneficiary of the first transaction. If the attacker tried to <em>physically</em> corrupt the ledger, everyone would ignore the invalid block.  The best defence against this attack is to ensure that multiple independent powerful actors have no incentive to collude.</p>

<p>The general principle of the TEN protocol is that it reverts to the behaviour of a typical non-confidential blockchain in case of hacks on the TEE technology. In other words, the safety of the ledger does not depend on the hardness of the TEEs; instead, what happens is that attackers can read transactions and data. Also, TEN does not delegate safety to a single actor by planning to support TEEs from multiple hardware manufacturers. In case of severe attacks, there are multiple mitigation mechanisms in place, the ultimate being that the L2 ledger is frozen, and everyone has the chance to withdraw using balance proofs.</p>

<p>TEN achieves data availability in the same way as all the other rollup solutions; the L1 is the source of data truth for the L2 network. Any L2 node with a valid TEE in possession of the shared secret can download the rollup chain from the L1, calculate the entire state inside its encrypted memory, and at the same time validate all transactions.</p>

<p>The following sections analyse the different threats against the TEN protocol.</p>

<h2 id="threats-to-the-tee-technology">Threats to the TEE Technology</h2>
<p>The TEN design considers that the TEE technology and the program inside are not easily hackable, so the protocol is not optimised to handle them. Attacks on TEEs have occurred in laboratories, so a secondary but essential concern is to prevent ultra-sophisticated actors with the ability to hack this technology from stealing funds or breaking the integrity of the ledger.</p>

<p><em>The threat model of TEN is that sophisticated attackers run an Aggregator node on a machine with a TEE they control, have access to the master seed and the entire ledger, and run any possible attack on it, including attacks on the physical CPU.</em></p>

<p>Assuming that such attacks are successful, the attacker can limit themselves to read-level access or an attempt to corrupt the ledger using a write-level attack.</p>

<h3 id="read-level-attacks">Read-Level Attacks</h3>
<p>Read-level hacks happen when the attacker can extract some information from the TEE. This threat is specific to confidential blockchains.</p>

<p>The only way to defend against these attacks is to carefully audit the code and keep the <em>Attestation Constraints</em> up to date. If this attacker is discreet, the information leak can continue until a software patch is published or until new hardware that removes this attack is released.</p>

<p>Another way to defend against it which will be considered in future versions, is to implement a scheme similar to key rotations.</p>

<p>The least severe read attack is a side-channel where the attacker can find information about a specific transaction. The most severe is when the attacker can extract the master secret and read all present and future transactions.</p>

<p>If such an attack is successful, the network is equivalent to the behaviour of a typical public blockchain where all transactions are public, and MEV is possible.</p>

<h3 id="write-level-attacks">Write-Level Attacks</h3>
<p>Write-level hacks are powerful in theory since they could enable the attacker to <em>write</em> to the ledger and thus be able to break its integrity if there were no other protections.</p>

<p>A write-level hack could happen if an attacker extracts the enclave key and signs hand-crafted rollups that contain invalid transactions or balances.</p>

<p><em>Note: This type of attack is viewed as the main threat to the protocol and thus handled explicitly.</em></p>

<p>The mechanism to prevent this attack is described in detail in the <a href="./ten-ethereum-interaction#withdrawals">Withdrawals</a> section.</p>

<p>The high level goal of the protections is to transform such an attack into a liveness attack on the withdrawal function.</p>

<h3 id="colluding-write-level-attacks">Colluding Write-Level Attacks</h3>
<p>An extreme variant of the <em>Write-level attack</em> is performed by a powerful group that hacked the TEE and was able to take complete control of all the Aggregator nodes.</p>

<p>The defence against this attack is to incentivise a reasonable number of Verifiers to watch the TEN ledger in real-time. These actors will detect a malicious head rollup and notice that no other valid fork is being published.</p>

<p><em>Note: One such actor monitoring the network will be the TEN Network Association, which has the mandate to keep the protocol functioning correctly. The protocol also rewards other independent parties to take on this job by assigning random rewards to Verifiers who can prove they are active.</em></p>

<p>Any L2 node can become an Aggregator quickly by benefiting from the censorship resistance of Ethereum.  To counter the attack, they will have to pay the stake and publish a correct rollup.</p>

<h3 id="attacks-against-the-fair-lottery-that-designates-the-winner-of-the-round">Attacks Against The Fair Lottery That Designates The Winner Of The Round</h3>
<p>The POBI protocol assigns a leader each round by using random numbers generated inside the TEE. An attacker that can hack the technology could generate a well-chosen number and thus win each round. This is not an attack against the safety of the ledger and is not of great concern.</p>

<p>If some Aggregator wins statistically many more rounds than they should, it will highlight the problem to the community.</p>

<p>A more dangerous variation of the attack is when the attacker can also read transactions and thus front-run and extract value.</p>

<p><em>Note: This area is under research</em>.</p>

<p>A variation of this attack is when the attacker cannot directly hack the TEE, but it is restarting the TEE in the hope of generating a lower nonce and thus improving their chances. This threat is mitigated by a delay introduced at the startup of the OVM, which will cause the attacker to miss out on that rollup cycle.</p>

<h2 id="other-threats-to-the-protocol">Other Threats To The Protocol</h2>
<p>This section analyses threats not directly linked to the TEE, although a hack against the TEEs might amplify them.</p>

<h3 id="invalid-rollup-attacks">Invalid Rollup Attacks</h3>
<p>The <em>Rollup Contract</em> only accepts signed rollups from Aggregators that can prove their TEE attestation, and unless the TEE itself is corrupted, it is impossible to publish invalid rollups. This means that such an attack will become a liveness attack when forks are detected in the rollup chain.</p>

<h3 id="empty-rollup-attacks">Empty Rollup Attacks</h3>
<p>An Aggregator winning a round can freely publish empty rollups, but that would not harm the system if there were multiple independent Aggregators. It will just slow down the network. TEN disincentivises this attack since the reward for the publisher is linked to the fees collected from the included transactions.</p>

<h2 id="sybil-attacks">Sybil Attacks</h2>
<p>This section analyses the threats that a powerful adversary who can create many Aggregators can pose on the protocol.</p>

<p>The reasoning around this attack is quite different from typical public blockchains.</p>

<p>There are two ways to run this attack against TEN depending on the capabilities of the attacker:</p>

<ol>
  <li>The attacker sets up N CPUs with TEE and pays the stake for each of them, where (N &gt; Total_Number_Of_Aggregators / 2).</li>
  <li>The attacker hacks the TEE and can impersonate many TEEs limited only by the stake. This attack has been analysed in the “Colluding write-level attack”.</li>
</ol>

<h3 id="sybil-attack-without-hacking-the-tee">Sybil Attack Without Hacking The TEE</h3>
<p>If the attacker cannot hack the TEE, they cannot deviate from the canonical chain or insert illegal transactions, as the attested software will not let them. Having a majority on the TEN network will not help with this. An attacker who wants to perform a double-spend attack on TEN will have to change the canonical chain already published in L1 blocks. To perform a double spend, the attackers have to perform a double-spend attack on the L1 blocks themselves that contain the rollups.</p>

<h3 id="economical-sybil-attacks">Economical Sybil Attacks</h3>
<p>Another type of attack, which a well-resourced actor can perform, is controlling many Aggregators to make a good return from the rewards. The more Aggregators someone controls, the more chance of getting a winning nonce.</p>

<p>There is no risk in altering the ledger or performing double-spend attacks. There is no risk of a Denial of Service attack either, by refusing to publish winning rollups since the incentives encourage other actors to quickly fill in gaps and publish rollups.</p>

<p>There are no risks of driving other Aggregators out of business by denying them the chance to win rollups since they will get the reward of being active nodes.</p>

<h3 id="catastrophic-events">Catastrophic Events</h3>
<p>One of the worst scenarios is a catastrophic event that leaves all the value locked.</p>

<p>This could happen in theory if all registered TEEs were simultaneously physically destroyed, and thus the master seed was permanently lost.</p>

<p>If a single TEE is not physically destroyed, and a single Ethereum node has a copy of the L1 ledger, the network can be restarted, since all the required information is stored on the L1, including the master seed encrypted with the key of the surviving enclave and all the rollups.</p>

<p>The defence against this is to achieve a reasonable decentralisation.</p>

<h2 id="mev-by-ten-aggregators">MEV By TEN Aggregators</h2>
<p>Transactions and processing are hidden from node operators. Still rollups contain some information and the node operator can query the balance of accounts they control.</p>

<p>To make this attack impractical, TEN introduces a slight delay that preserves the user experience of public blockchains.</p>

<p>The TEE will emit events and respond to balance requests only after it received proof that the rollup was successfully published in an L1 block. This mechanism will prevent an Aggregator from probing for information while creating a rollup.</p>

<p>An Aggregator wishing to attack this scheme would have to quickly create valid Ethereum blocks while executing user transactions, which is highly impractical since there is a hardcoded minimum value for the mining difficulty.</p>

<h2 id="threats-to-the-pobi-protocol">Threats To The POBI Protocol</h2>
<p>The POBI protocol handles most failure scenarios using a set of incentive rules.</p>

<h4 id="1-the-winning-sequencer-does-not-publish">1. The winning sequencer does not publish</h4>
<p>The winning Aggregator is incentivised to publish the rollup in order to receive the reward, which means this scenario should only occur infrequently if the Aggregator crashes or malfunctions. If it happens, it will only be detected by the other Aggregators when the next L1 block does not contain the winning rollup that was gossiped about.</p>

<p>In this situation, every Aggregator will:</p>

<ul>
  <li>Discard the current rollup.</li>
  <li>Unseal the previous rollup.</li>
  <li>Add all current transactions to it.</li>
  <li>Then seal it using the last empty block.</li>
  <li>Gossip it.</li>
</ul>

<p>In effect, this means that the previous round is replayed. The winning Aggregator of this new round has priority over the reward in case the previous winner is added in the same block.</p>

<h4 id="2-the-winning-sequencer-adds-too-little-gas-and-the-rollup-sits-in-the-mempool-unconfirmed">2. The winning sequencer adds too little gas, and the rollup sits in the mempool unconfirmed</h4>
<p>This scenario has the same effect as the previous one is handled in the same way. If the rollup is not in the next block, the round is replayed.</p>

<p>Publishing with insufficient gas is, in effect, punished by the protocol because it means that on top of missing the rollup reward, the Aggregator also pays the L1 gas fee.</p>

<h2 id="competing-l1-blockchain-forks">Competing L1 Blockchain Forks</h2>
<p>In theory, different L2 Aggregators could be connected to L1 nodes that have different views of the L1 ledger. This will be visible in the L2 network, as gossiped rollups pointing to L1 blocks from the two forks. Each Aggregator will have to make a bet and continue working on the L1 fork that it considers to be legitimate, the same behaviour as any L1 node.</p>

<p>This is depicted in <a href="./rollup-data-structure">Rollup Data Structure</a>.</p>

<p>If it proves that the decision an Aggregator made was wrong, it has to roll back the state to a checkpoint and replay the winning rollups.</p>

<h2 id="trust-model">Trust Model</h2>
<p>The analysis in this section is based on a <a href="https://vitalik.ca/general/2020/08/20/trust.html">framework</a> defined by Vitalik Buterin, the creator of Ethereum.</p>

<p>TEN is slightly different from typical blockchains or L2s because it introduces another actor into the trust model, the hardware manufacturer.</p>

<p>These are the questions that will be answered using the terminology from the framework.</p>

<ol>
  <li>How many people do you need to behave as you expect? Out of how many?</li>
  <li>What kinds of motivations are needed for those people to behave? Do they need to be altruistic or just profit-seeking? Do they need to be uncoordinated?</li>
  <li>How badly will the system fail if the assumptions are violated?</li>
</ol>

<h3 id="actors">Actors</h3>
<p>The following groups are actors in the system.</p>
<ol>
  <li>The TEN network may contain a few thousand nodes, from which a minority core set will be <em>Aggregators</em> and the rest <em>Verifiers</em>. The governance body can control this number by setting some parameters.</li>
  <li>Another important group in this is the token holders, who have governance powers.</li>
  <li>The supported hardware TEE manufacturers.</li>
  <li>The auditors.</li>
</ol>

<h3 id="notation-1">Notation</h3>
<ol>
  <li>TEN_N - number of TEN nodes ~ 1000.</li>
  <li>Ethereum_N - number of Ethereum nodes.</li>
  <li>TEE_Manufacturer_N - number of manufacturers. Small number, but composed of large reputable companies.</li>
  <li>Token_Holders_N - number of TEN token holders. Many thousands.</li>
</ol>

<h3 id="liveness">Liveness</h3>
<p>There are multiple aspects to consider when analysing the liveness trust model. Since TEN is fully decentralised at the network level, as long as one single Aggregator is alive, the network is alive and processing user transactions.</p>

<p>For transaction processing: 1 of TEN_N, where the motivation of nodes is profit-seeking.</p>

<p>For processing withdrawals and thus reaching finality, the analysis is more complex. Since withdrawals are processed automatically from the instructions found in the rollups, the trust model for the liveness of this feature is the model for safety.</p>

<h3 id="safety">Safety</h3>
<p>The safety of TEN is based on a couple of layers, which transform a safety attack into a liveness attack.</p>

<p>Note that the safety of the ledger is at risk only if there are hacks in the confidential hardware technology.</p>

<p>Given that hardware manufacturers are generally large and reputable companies, they act as the first barrier. Their motivation is ultimately profit-seeking because vulnerabilities in the hardware they create will lead to lower sales and reputational damage.</p>

<p>Hardware layer: 1 of TEE_Manufacturer_N, where the motivation is profit-seeking. Note that this assumes that the hardware manufacturer introduces a bug in the TEE implementation to attack the ledger. Normally the threat is lower since a single user with a valid TEE by any manufacturer will be able to stop an attack.</p>

<p>If there is a successful attack against the TEE, the next defence is a single active L2 node that publishes a valid rollup.
1 of TEN_N, where the motivation of nodes is profit-seeking.</p>

<p>The next line of defence are the token holders, who will vote on L1 to update the Attestation Constraints, to fix the vulnerability. They are invested in the community because they hold the token, which means they profit if it functions correctly: Token_Holders_N/2 of Token_Holders_N, where motivation is profit-seeking</p>

<p>Note that the attacker is not directly profit seeking because there is no possibility to withdraw assets until the fork is resolved.</p>

<h3 id="how-badly-will-the-system-fail-if-the-assumptions-are-violated">How Badly Will The System Fail If The Assumptions Are Violated?</h3>
<p>If all supported hardware manufacturers colluded, they would be able to break the safety of the ledger.</p>
<h1 id="governance">Governance</h1>
<p>Governance for the TEN protocol, the reference implementation, and the network configuration will be made explicit and visible to all. TEN governance thinking is derived from the experience of Bitcoin and Ethereum.</p>

<p>There are several types of control exercised in a decentralised system:</p>
<ol>
  <li>Explicit control exercised by a group of people using direct signing or voting.</li>
  <li>Implicit control implemented in an immutable protocol.</li>
  <li>Implicit control implemented in a protocol that itself is represented by an open-source codebase that is mutable.</li>
</ol>

<p>Note that almost nothing is truly immutable because a codebase or even hardware executing even the most immutable protocol can change its behaviour, or it can be changed. In theory, a truly immutable system could be achieved using various hash constraints within TEEs; however, allowing for upgrades is a more desirable outcome. Ultimately, for all other cases, there is an explicit governance process somewhere.</p>

<p>Bitcoin miners, for example, have some power to determine the rules by choosing which version of the core code to install and to produce blocks with. If there is disagreement, there is a fork, and the user community ultimately decides what value to assign to each fork. This is only a problem if the competing forks have similar mining power, and thus security. For day-to-day upgrades, miners have the de-facto decision power, but in case of disagreements, the users have the ultimate power through free markets.
This is currently the golden standard for decentralised governance, with advantages and disadvantages.</p>

<p>It gets even more complicated on networks like Ethereum with smart contract capabilities. On the one hand, similar to Bitcoin, the end-users decide which miners have chosen the correct version. On the other hand, the applications running on top of Ethereum have their governance requirements. In the early days, <em>The DAO</em> fell into the second category: <em>Implicit controls implemented in an immutable protocol.</em>, but it was exploited, and in addressing this by forking Ethereum and indirectly creating Ethereum Classic, it became apparent that there was actually a mutable codebase behind the immutable protocol (the Ethereum codebase itself). It also became apparent that users have the ultimate power as they indirectly voted with their wallets on the preferred approach of handling that hack, and Ethereum Classic has much lower adoption than the mutated Ethereum.</p>

<p>After that hard lesson, most Ethereum smart contracts have component contracts that can be upgraded through an explicit governance process since it is unlikely the community will again provide “get out of jail free” cards to application developers. Sometimes the governance is obfuscated, but generally, if the contract is <em>upgradeable</em>, it means someone is in charge.</p>

<p>The key difference between the golden standard of Bitcoin, and typical smart contract governance, is that the end-users no longer have any power to choose which “smart contract fork” they prefer. Using the original smart contract and adding some value to it, they are at the mercy of the application governors.</p>

<p>Since the TEN protocol is anchored in Ethereum as a smart contract, it cannot rely on TEN end-users to hold the ultimate power.
The next best thing is to be very explicit about all the system’s controls and achieve separation of decision-making (which can be devolved to token-holders and articulated in a governance specification as proposals) from execution (which relies on individuals pushing buttons).</p>

<h2 id="ten-controls">TEN Controls</h2>
<p>Building on the above, the following controls are exercised within TEN.</p>

<h3 id="1-the-tee-attestation-constraints">1. The TEE Attestation Constraints.</h3>
<p>The <em>Attestation Constraints</em> (AC) control which software is allowed to run inside the TEE and can process the user transactions and create the rollups. A group of independent, reputable, and competent security auditors has to analyse the code and approve it by signing it carefully. The constraints contain the keys of the <em>approved auditors</em>.</p>

<p>The parties who have the power to set the AC and thus appoint auditors ultimately control the software.</p>

<p>This concern is not entirely different from the smart contracts security auditors, except that typically users decide which auditors they trust by using or not using those contracts.</p>

<h3 id="2-administration-of-ethereum-management-contracts">2. Administration Of Ethereum Management Contracts.</h3>
<p>Like most other Ethereum applications, these contracts will have upgradeable parts to cater for bugs and new features. Whatever is upgradeable means that the <em>administrators</em> have full control over those aspects.</p>
<ol>
  <li>Bridge logic</li>
  <li>Rollup logic</li>
  <li>Attestation logic</li>
</ol>

<p>In the example above, the auditors are a fixed list. However, that might not be practical, as companies might appear or disappear. The list of approved auditors has to be managed by a proposal and vote process by the community without any requirement for central intervention. Going a level deeper, the code that manages this process might need to be upgradeable, so someone ends up controlling it.</p>

<h3 id="3-creating-rollups">3. Creating Rollups</h3>
<p>Another power, equivalent to the L1 stakers or miners, is held by TEN Aggregators. They run attested software and hardware and have paid a stake.</p>

<p>They have the power to append to the L2 ledger, but they do not have the power to choose competing software and thus create forks.</p>

<h3 id="4-canonical-rollup-chain">4. Canonical Rollup Chain.</h3>
<p>In a typical L1, the canonical chain is ultimately decided by its users from one of the competing forks because the ledger is ultimately coupled to the value of the coin.</p>

<p>In TEN, the Aggregators have to run attested software, which constraints their free will unless they can hack the TEE technology.</p>

<p>According to the rules implemented, a valid TEE does not sign a rollup building on top of a chain that is not canonical, so any hack is immediately visible.</p>

<p>Additional complexity involves the withdrawal process, which depends on assured finality on the canonical chain.</p>

<h3 id="5-slashing-the-stake-of-misbehaving-parties">5. Slashing The Stake Of Misbehaving Parties.</h3>
<p>Aggregators that hack an enclave and attempt to break the ledger’s integrity are discovered by the protocol and are punished by slashing to disincentivise such behaviour further.</p>

<p>Slashing is an implicit process carried out by the Management Contract based on predefined rules. However, ultimately it is itself controlled by the code governance.</p>

<h3 id="6-expected-monthly-operational-cost-for-nodes">6. Expected Monthly Operational Cost For Nodes</h3>
<p>TEN has a fee structure that delivers a predictable income for node operators and a predictable fee for users. In order to derive a fee that sufficiently compensates nodes, a value that represents the monthly operational cost for each node must be set.
This variable also has the power to increase or decrease demand for running a node helping ensure a balance between decentralisation and end-user cost.</p>
<h1 id="appendix">Appendix</h1>
<h2 id="contributors">Contributors</h2>
<p>The TEN project is decentralised in nature, and this whitepaper has benefited enormously with feedback from the following contributors:</p>
<ul>
  <li>Richard Gendal Brown</li>
  <li>Mike Hearn</li>
  <li>Moritz Platt</li>
  <li>Tim Brinded</li>
  <li>Fred Dalibard</li>
  <li>Stefan Iliev</li>
  <li>Zbigniew Czapran</li>
</ul>

<p>Additional feedback is welcome, and all reviewers will be credited.</p>

<h2 id="glossary">Glossary</h2>
<p><strong>Aggregator</strong>
A node that participates in an L2 network and collaborates with other Aggregator nodes to manage the L2 contracts and confirm correctness of transactions. Specifically, it participates in transaction gossip, and may propose transaction rollups to be registered with the L1 blockchain.</p>

<p><strong>Attestation Constraints</strong>
Means of controlling which software is allowed to run inside the Trusted Execution Environment.</p>

<p><strong>Automated Market Maker / AMM</strong>
Uses liquidity pools to allow digital assets to be traded automatically and without permissions.</p>

<p><strong>Block Reward</strong>
An amount of OBX which is given to node operators to cover their costs to validate and publish blocks.</p>

<p><strong>Enclave Key / EK</strong>
Collection of one or more cryptographic keys used for encrypting and decrypting data unique to a specific enclave, digitally signing data and identifying a Trusted Execution Environment.</p>

<p><strong>ERC-20</strong>
Ethereum Request for Comments 20, proposed by Fabian Vogelsteller in November 2015, is a token standard that implements an API for tokens within Smart Contracts.</p>

<p><strong>Ethereum Virtual Machine / EVM</strong>
A virtual computer whose existence is maintained by thousands of connected real-world computers running an Ethereum client.</p>

<p><strong>Gas</strong>
The unit that measures the amount of computational effort required to execute specific operations on the Ethereum network.</p>

<p><strong>Gas Price</strong>
The levy imposed for every computation executed on the Ethereum network to encourage good behaviour, e.g. prevent bad actors from spamming the network.</p>

<p><strong>Genesis Enclave</strong>
The first Trusted Execution Environment to join a new network. The Genesis enclave propagates the master seed to the other attested nodes by encrypting it with specific Trusted Execution Environment keys.</p>

<p><strong>Host</strong>
The party controlling the physical server that runs the Trusted Execution Environment. In the threat model of typical confidential computing applications, including TEN, the host is an adversary of the system.</p>

<p><strong>L1 Management Contract</strong>
The smart contract that runs on Ethereum and handles all L1 concerns.</p>

<p><strong>Layer 1 / L1</strong>
The public Ethereum blockchain and network.</p>

<p><strong>Layer 2 / L2</strong>
A second network built on top of an L1 network and dependent on it. An L2 network expands on the capabilities of the L1 network by increasing capacity or enhancing functionality.</p>

<p><strong>Maximal Extractable Value / MEV</strong>
Participants in the network may extract value by observing user transactions and then preempting them by inserting their own transaction ahead in the processing queue and influencing the price of an asset in order to extract a profit.</p>

<p><strong>Non-Fungible Token / NFT</strong>
A unique and non-interchangeable unit of data stored on a digital ledger.</p>

<p><strong>TEN Public Events</strong>
Special events emitted by L2 contracts that are included in the rollups in plaintext, and are exposed to L1 contracts once rollups reach finality. It is a mechanism by which TEN can publish information.</p>

<p><strong>TEN</strong>
The utility token used by TEN.</p>

<p><strong>Off-Chain</strong>
Activity happening away from the Layer 1 blockchain.</p>

<p><strong>Optimistic Rollup</strong>
Optimistic rollups assume that all transactions are valid and submit batches without performing any computation. They include a challenge period during which anyone can dispute the legitimacy of the data contained in a batch. If a fraudulent transaction is detected, the rollup executes a so-called fraud proof and runs the correct transaction computation using the data available on Layer 1.</p>

<p><strong>Over-the-counter / OTC</strong>
A venue to provide bespoke financial agreements or options negotiated between counterparties as opposed to being listed on an exchange.</p>

<p><strong>Patricia Tree Root</strong>
A Patricia Tree (or Trie), is a data structure used in the Ethereum model to represent the receipt trie, the world state trie, the account storage trie, and the transaction trie. Only the root node of the trie is stored in the ethereum block, and it represents a single cryptographic proof for the entire state.</p>

<p><strong>Proof Of Block Inclusion / POBI</strong>
TEN’s novel decentralised round-based consensus protocol based on a fair lottery and on synchronisation with the L1 designed for L2 rollups.</p>

<p><strong>Rollup</strong>
L2 solutions that perform transaction execution outside the main L1 chain, but post transaction data on L1. A rollup is a batch of transactions that were executed by the L2 Verifiers.</p>

<p><strong>Root Provisioning Key / RPK</strong>
A cryptographic key randomly created and retained by Intel. It is the basis for how the processor demonstrates that it is a genuine Intel SGX CPU at a specific trusted computing base.</p>

<p><strong>Root Sealing Key / RSK</strong>
A cryptographic key that is unique to an enclave which that enclave uses to encrypt and decrypt data stored outside the enclave boundary.</p>

<p><strong>Sequencer</strong>
A sequencer is the selected Aggregator which builds a rollup in a round.</p>

<p><strong>SGX</strong>
Software Guard Extensions, a technology provided by Intel, a major CPU manufacturer. An SGX CPU has an area for encrypted computation, which the operator cannot access, secured by a private key burnt into the CPU during manufacture.</p>

<p><strong>Smart Contract / Contract</strong>
A user application running on a blockchain network which holds data or state, responds to user commands, and may store and manage assets or money.</p>

<p><strong>Stake</strong>
A non-negligible amount of value which is given over to an activity or process to demonstrate commitment to follow the rules for that activity or process.</p>

<p><strong>Trusted Execution Environment / TEE</strong>
An environment where contracts may be managed in a deterministic, repeatable and auditable way, based on a set of trust dependencies.</p>

<p><strong>Trusted computing base / TCB</strong>
 The set of computing technologies that must be working correctly and not be malicious or compromised for a security system to operate.</p>

<p><strong>Utility Token</strong>
Tokens which are intended to provide digital access to an application or service.</p>

<p><strong>Verifier</strong>
A <em>light</em> L2 node which observes transaction rollups published to the L1 blockchain, and can participate in possible disputes. Any Verifier can become an Aggregator by registering on the L1 contract and pledging some stake.</p>

<p><strong>ZK-rollups</strong>
Zero knowledge rollups generate cryptographic proofs that can be used to prove the validity of transactions.</p>

<h2 id="data-model">Data Model</h2>
<p>This diagram shows the data structure for the Management Contract and Aggregator:
<img src="./images/management-contract.png" alt="management-contract" /></p>

<p>This diagram shows the data structure for the rollup and withdrawal:
<img src="./images/rollup.png" alt="rollup" /></p>

<p>This diagram shows the data structure for the transactions and account:
<img src="./images/transaction-account.png" alt="transaction-account" /></p>

<h2 id="design-alternatives">Design Alternatives</h2>
<p>This section describes alternatives considered and discarded.</p>

<h3 id="alternative-l1-deposit-management">Alternative L1 Deposit management</h3>
<p>On a high level, a user has to deposit ERC tokens on the L1 Management Contract, and the same amount has to be credited to the user’s account on TEN. This is not straightforward since finality is probabilistic.
One option to achieve this is to wait a number of L1 blocks for confirmation. This has some clear disadvantages.</p>

<p>Another option is to introduce a dependency mechanism between the L2 rollup and the L1 blocks. Basically, the L2 transaction that credits the TEN account will be in an L2 rollup that will only be accepted by the Management Contract if the dependency is part of the ancestors of the current block.  This option is discarded because in the case where the L1 deposit gets reorganised away before the rollup is created, the rollup which contains the L2 deposit transaction is invalidated.</p>

<h3 id="alternative-l1-theft-prevention">Alternative L1 Theft Prevention</h3>
<p>There is a pool of liquidity stored in the L1 Bridge contract, which is controlled by the group of TEEs who maintain the encrypted ledger of ownership. Some users will want to withdraw from the L2 and go back to L1, which means the Management Contract will have to allow them to claim money from the liquidity pool.</p>

<p>In case one of the Aggregators is able to hack the TEE, they will be able to produce a proof that they own much more and thus run with it.</p>

<p>To solve this we have a couple of options.
We could organise the Aggregators in a BFT setup, and require that 2/3 of them sign over each rollup. The major disadvantage with this approach is that the finality of an L2 transaction will depend on both the BFT finality and the L1 finality. Another disadvantage is that a determined hacker with the means to break secure hardware could also amass the majority of staking power and be unchallenged.</p>

<p>Another option with a better trust model is to introduce a challenge mechanism similar to the optimistic rollups. The disadvantage is that it introduces a delay, and a concept of probabilistic finality.</p>

<p>The data structure containing the rollups is a chain that can have multiple heads. The Management Contract cannot evaluate which one is correct because it cannot execute the transactions inside. But there are some simple rules that can be applied. For example, if a branch does not progress for N blocks it is considered dead. If at the moment of withdrawal there is only a single active head rollup, then all the system has to do is wait for a reasonable number of blocks (20-50) to ensure that there is no censorship attempt on L1. If there is a fork, then the number of blocks has to be increased to allow one of the forks to die out naturally. If it does not then all withdrawals will be locked, and the contract will enter a special procedure.</p>

<h3 id="alternative-revelation-options">Alternative Revelation Options</h3>
<p>The solution will reveal all transactions after one year through a key-rotation process. An alternative policy could be to specify a ratio of transactions (e.g. 1%) are revealed either immediately or subsequently. Illegal transaction detection then becomes risk-based, but the ratio cannot be high enough to be a disincentive and yet still provide utility.</p>

<h3 id="alternative-nonce-generation">Alternative Nonce Generation</h3>
<p>The Aggregator host must not be able to repeatedly submit the rollup proof to the TEE to get a new random nonce, and thus achieve a low nonce in order to win the Aggregator selection round. Monotonic counters were considered but an alternative is to make the nonce deterministic. The nonce is deterministically derived from the L1 block hash combined with the public key of the enclave. This achieves the same purpose of being a fair lottery assuming there is no collusion between L1 miners and L2 Aggregators. Even if there was collusion, the cost of gaming the L1 hash might be too high in a proof of work network. In a <em>Proof of Stake</em> network, on the other hand, collusion with L1 would pretty much mean that each round the L1 winner will also win the L2 round.</p>

<h3 id="alternative-privacy-revelation">Alternative Privacy Revelation</h3>
<p>There are several options for revealing private data to allow law enforcement agencies to prosecute illegal behaviour and deter criminals from taking advantage of TEN’s privacy features:</p>
<ul>
  <li>Not make a provision to reveal on the basis that TEN is a platform and is un-opinionated on what it is used for.</li>
  <li>The transaction encryption key can be rotated and revealed periodically with a delay, such that any interested party can view all transactions. This is the solution we chose, but with some application-level flexibility.</li>
  <li>A governance committee can approve some data mining enclaves that will have access to the shared secret and output suspicious activity.</li>
</ul>

<p>From the outset TEN will rotate the encryption key every year and reveal historic keys in the first phase, and decide later if additional mechanisms are required. A case-by-case revelation based on authority demands is time-consuming and prone to political interference. It is also difficult to determine objectively what is a bona-fide authority which introduces a political dilemma.</p>

<p><a href="https://github.com/ten-protocol/obscuro.github.io/blame/main/obscuro-whitepaper/amalgamated.md">Page history</a></p>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/tenprotocol" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/ten-protocol" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 TEN. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
